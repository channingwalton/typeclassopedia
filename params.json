{"name":"Typeclassopedia","tagline":"My tinkering to understand the typeclassopedia.","body":"The Road to the Typeclassopedia\r\n===============================\r\n\r\nPeople learn in many different ways. For computer science and programming, some enjoy starting from the math, the theory, and proofs. From there they find their way to practical concerns in everyday development. They think in abstract algebra and category theory, encoding their solutions in their chosen language.\r\n\r\nThats awesome.\r\n\r\nBut other people learn in a different way. They like to learn by example, with problems solved with patterns and techniques that later they learn have names and ideas rooted in mathematics.\r\n\r\nThere are a lot of excellent books, papers and blogs that follow the first path, usually because the authors tend to be the kind of people that are happy to learn from the math and theory, applying it later.\r\n\r\nThis book follows the second path, describing a set of ideas collectively called the Typeclassopedia, by starting from a problem and developing a solution.\r\n\r\nThe Path\r\n========\r\n\r\nOption\r\n------\r\n\r\nHere is some code that returns a value:\r\n\r\n``` scala\r\n  trait Blub {\r\n\r\n    /**\r\n    * @return a Foo or null\r\n    */\r\n    def foo(): Foo\r\n  }\r\n```\r\n\r\nThis is a common pattern, the method returns a Foo instance or null if the method cannot do its job. But, anyone calling this method needs to know that the result might be null which is extremely error prone and completely insane. We can do better than that by returning a value that represents that fact that the method might not be able to return a result, an optional value.\r\n\r\nInstead of the insidious null, we can represent this optional value with a type called *Option*. A type that represents a value that may or may not exist.\r\n\r\nHere it is:\r\n\r\n``` scala\r\n  sealed trait Option[+A]\r\n\r\n  // we have a value\r\n  case class Some[A](v: A) extends Option[A]\r\n\r\n  // no value\r\n  case object None extends Option[Nothing]\r\n```\r\n\r\nNotice that `None extends Option[Nothing]`, `Nothing` is the bottom type which extends all other types. Because `Option` is covariant, `Option[Nothing]` extends all other `Option` types.\r\n\r\nSo now Blub looks like:\r\n\r\n``` scala\r\n  trait Blub {\r\n    def foo(): Option[Foo]\r\n  }\r\n```\r\n\r\nTwo things have happened:\r\n\r\n1.  the method now returns a type that represents the optional nature of the returned value, no more `null`!\r\n2.  the comment has gone. It is not needed anymore because the method signature is sufficient.\r\n\r\nBut now we have another problem, how do we work with the result? We certainly don't want to explicitly detect whether the result is a *Some* or *None* everytime by pattern matching or other means.\r\n\r\nInstead we can add a method to Option that enables a function to be applied to the value. Traditionally, that method is called *map*.\r\n\r\n``` scala\r\n  trait Option[+A] {\r\n    def map[B](f: A ⇒ B): Option[B] =\r\n      this match {\r\n        case Some(a) ⇒ Some(f(a))\r\n        case None ⇒ None\r\n      }\r\n  }\r\n```\r\n\r\nIf the Option is a Some, then the functon can be applied to the value and a new Some returned with the result. If the Option is a None, then map can only return None since there is no value to apply the function to.\r\n\r\nSo we can now work with values in options not by pattern matching but by mapping with a function.\r\n\r\nList\r\n----\r\n\r\nLists are important data structures and its self-evident why they are needed.\r\n\r\nScala's standard library comes with a List so we won't go into writing one (hint: write one yourself as an exercise) but there are a couple of things to point out.\r\n\r\n1.  Like Option, List requires a type parameter. eg List\\[Int\\] for a list of integers\r\n2.  It has a map method like Option\r\n\r\nList's map method is roughly like this (but not exactly for reasons we won't go into here):\r\n\r\n``` scala\r\n  def map[U](f: T ⇒ U): List[U]\r\n```\r\n\r\nLike Option, the map method takes a function, f, and returns a new List.\r\n\r\nFor comprehensions\r\n------------------\r\n\r\nIn scala, if an object has a `map` method like Option and List do, you can use a *for comprehension*, syntactic sugar that compiles to map:\r\n\r\n``` scala\r\n  val x: Option[String] = ...\r\n\r\n  for {\r\n    v <- x\r\n  } yield v.length\r\n\r\n  // is the same as\r\n  x.map(v ⇒ v.length)\r\n```\r\n\r\nBut for comprehensions can do a lot more as we will see later.\r\n\r\nThe First Abstraction\r\n---------------------\r\n\r\nLooking at Option and List we find that both *map* methods are very similar:\r\n\r\n1.  They both take a function that transforms the element(s) of List and Option\r\n2.  They both obey some obvious *laws*\r\n    1.  Identity: If the function given is the *identity* function, then the returned Option or List is the same as the original\r\n    2.  Composition: If map is first passed `f: A ⇒ B`, and then `g: B ⇒ C`, its the same as passing a composite function: `f andThen g`, or `g compose f`.\r\n\r\nSo the question is, can we come up with something more general, and if we can, how do we express it and use it?\r\n\r\nUnsurprisingly the answer is yes because in Scala, and other languages like it, you can *abstract over type constructors*.\r\n\r\nLets look at the map method again but recast it slightly differently:\r\n\r\n``` scala\r\n  def map[A, B](o: Option[A], f: A ⇒ B): Option[B]\r\n```\r\n\r\nSo instead of a map method on Option, we can put this method *somewhere* and call it. Its more cumbersome but stay with me. Lets do the same for List:\r\n\r\n``` scala\r\n  def map[A, B](o: List[A], f: A ⇒ B): List[B]\r\n```\r\n\r\nThese method signatures are practically identical and vary only in the type argument. We can define this method in terms of any type that takes a single parameter, a type constructor, like this:\r\n\r\n``` scala\r\n  trait MappingThing[M[_]] {\r\n    def map[A, B](m: M[A], f: A ⇒ B): M[B]\r\n  }\r\n```\r\n\r\nWe will come to what its called later, the important point is that the trait has a *map* method for any M, that is a type constructor, hence the type parameter is M\\[\\_\\].\r\n\r\nThe implementations for List and Option are straight forward:\r\n\r\n``` scala\r\n  object ListMappingThing extends MappingThing[List] {\r\n    def map[A, B](m: List[A], f: A ⇒ B): List[B] = ??? // map a list\r\n  }\r\n\r\n  object OptionMappingThing extends MappingThing[Option] {\r\n    def map[A, B](m: Option[A], f: A ⇒ B): Option[B] = ??? // map an option\r\n  }\r\n```\r\n\r\nNote that List and Map do not need their map methods anymore, we can use these two class instead, but how?\r\n\r\nIt would be very inconvenient to have to call `ListMappingThing.map` or `OptionMappingThing.map` directly, and actually totally useless when we've written code that doesn't know if we have a List or Option, code that has abstracted over the type constructor itself.\r\n\r\nThe solution is to use the typeclass pattern explained *above*. Code that needs a MappingThing can ask the compiler to provide it:\r\n\r\n``` scala\r\n  def launch[A, M[_]](m: M[A])(implicit mappingThing: MappingThing[M]): Result = {\r\n    val v: M[B] =  mappingThing.map(m, myFunkyFunction)\r\n\r\n    // do things with v and return a result\r\n  }\r\n```\r\n\r\nBut to make the Option and List MappingThings available for the compiler to find we need to make their instances implicit:\r\n\r\n``` scala\r\n  object AllTheMappingThings {\r\n    implicit object ListMappingThing extends MappingThing[List] {\r\n      def map[A, B](m: List[A], f: A ⇒ B): List[B] = ??? // map a list\r\n    }\r\n\r\n    implicit object OptionMappingThing extends MappingThing[Option] {\r\n      def map[A, B](m: Option[A], f: A ⇒ B): Option[B] = ??? // map an option\r\n    }\r\n  }\r\n```\r\n\r\nI have put the instances inside another object, but the right place for it is in the List and Option companion objects.\r\n\r\n### Summary\r\n\r\nWe have learnt a new way to decouple behaviour from data types using typeclasses that has numerous advantages:\r\n\r\n1.  The concept of mapping, the map method, has been extracted to its own type. The operation now has a life of its own independent of the specific types that support it.\r\n2.  Code can now be written more generally, and therefore be more generally useful, in terms of the MappingThing typeclass, not concrete instances. We don't need to write the *launch* method twice, once for Option and once for List.\r\n3.  Now that we have a typeclass, anyone can write more of them for whatever types they want. Suddenly code written in terms of MappingThing can be used in all kinds of different contexts.\r\n\r\n### The Name\r\n\r\nWhat we've just invented is some called a *functor*. Mathematically, a functor is a mapping between so-called categories, but we aren't going to go there.\r\n\r\nSquash it\r\n---------\r\n\r\nWe have a small problem with our map method, it can return anything at all. Why is that a problem?\r\n\r\n``` scala\r\n  // a function that returns an option\r\n  def sqrt(x: Double): Option[Double] = if (x >=0) Some(math.sqrt(x)) else None\r\n\r\n  // a value in an option\r\n\r\n  val x: Option[Int] = ???\r\n\r\n  val y: Option[Option[Int]] = x.map(v ⇒ sqrt(v))\r\n```\r\n\r\ny has ended up as an Option of an Option of Int which is annoying. So to handle this special case we are going to introduce a new method called *flatMap*. In Option it looks like this:\r\n\r\n``` scala\r\n  sealed trait Option[A] {\r\n    def map[B](f: A ⇒ B): Option[B] = ???\r\n\r\n    def flatMap[B](f: A ⇒ Option[B]): Option[B] =\r\n      this match {\r\n        case None ⇒ None\r\n        case Some(x) ⇒ f(x)\r\n      }\r\n  }\r\n```\r\n\r\nList has a similar method.\r\n\r\nThis method turns out to be very useful. Lets assume we have two Options and we want to work with the values of both in some way, flatMap will be useful:\r\n\r\n``` scala\r\n  val x: Option[Int] = ???\r\n  val y: Option[Int] = ???\r\n\r\n  val sum: Option[Int] = x.flatMap(xv ⇒ y.map(yv ⇒ xv + yv))\r\n```\r\n\r\nThis doesn't look so nice but fortunately scala's for comprehension deals with this by offering syntactic sugar for both map and flatMap. The above is identical to:\r\n\r\n``` scala\r\n  val sum: Option[Int] =\r\n    for {\r\n      xv <- x\r\n      yv <- y\r\n    } yield xv + yv\r\n```\r\n\r\nMuch better.\r\n\r\nList has a similar method so that we can work with multiple lists like this:\r\n\r\n``` scala\r\n  val x: List[Int] = ???\r\n  val y: List[Int] = ???\r\n\r\n  val sums: List[Int] =\r\n     for {\r\n      xv <- x\r\n      yv <- y\r\n    } yield xv + yv\r\n```\r\n\r\nThe Second Abstraction\r\n----------------------\r\n\r\nLooking at Option and List we find that both *flatMap* methods are very similar, and as with the map method we can recast it a little:\r\n\r\nOption:\r\n\r\n``` scala\r\n  def flatMap[A, B](o: Option[A], f: A ⇒ Option[B]): Option[B]\r\n```\r\n\r\nList:\r\n\r\n``` scala\r\n  def flatMap[A, B](o: List[A], f: A ⇒ List[B]): List[B]\r\n```\r\n\r\nThese methods are practically identical, what we can do is define this method in terms of any type that takes a single parameter, a type constructor, like this:\r\n\r\n``` scala\r\n  trait FlatMappingThing[M[_]] {\r\n    def flatMap[A, B](m: M[A], f: A ⇒ M[B]): M[B]\r\n  }\r\n```\r\n\r\nThe implementations for List and Option are:\r\n\r\n``` scala\r\n  object AllTheFlatMappingThings {\r\n    implicit object ListFlatMappingThing extends FlatMappingThing[List] {\r\n      def flatMap[A, B](m: List[A], f: A ⇒ List[B]): List[B] = ???\r\n    }\r\n\r\n    implicit object OptionFlatMappingThing extends FlatMappingThing[Option] {\r\n      def flatMap[A, B](m: Option[A], f: A ⇒ Option[B]): Option[B] = ???\r\n    }\r\n  }\r\n```\r\n\r\nAnd using this code with typeclasses:\r\n\r\n``` scala\r\n  def launch[A, M[_]](m: M[A])(implicit flatMappingThing: FlatMappingThing[M]): Result = {\r\n    val mapped: M[B] =  flatMappingThing.flatMap(m, myFunkyFunction)\r\n    // return a result\r\n  }\r\n```\r\n\r\nSo this is very similar to the functor case.\r\n\r\n### Summary\r\n\r\nWe have applied the same pattern as the functor above, but this time for the flatMap method. This enables us to cope with multple values of Options, Lists or any other kind of type constructor, or functions that return Options, Lists, etc.\r\n\r\n### The Name\r\n\r\nStand back ... its a Monad!\r\n\r\nThere is a little more to a monad than just a flatMap method, it needs to obey some laws too which we will skip, but if you're interested search [Google](https://www.google.com/search?q=scala+monad+laws) for Scala Monad Laws.\r\n\r\nSyntax\r\n------\r\n\r\nThe abstractions above are great but because we've moved the map and flatMap methods to typeclasses, scala won't let you use for-comprehensions since the map and flatMap method are on the typeclasses. In the specific case of Option and List they do have those methods because they are part of the Scala library and thats what the original authors did. But if you had a new type for which you'd defined typeclass instances, then that new type won't have map and flatMap.\r\n\r\nThe solution is to provide some syntax for any type that has a Functor or Monad typeclass.\r\n\r\n``` scala\r\n  implicit class FunctorSyntax[F[_]: Functor, A](v: F[A]) {\r\n    def map[B](f: A ⇒ B): F[B] = implicitly[Functor[F]].map(v, f)\r\n  }\r\n```\r\n\r\n``` scala\r\n  implicit class MonadSyntax[M[_]: Monad, A](v: M[A]) {\r\n    def flatMap[B](f: A ⇒ M[B]): M[B] = implicitly[Monad[F]].flatMap(v, f)\r\n  }\r\n```\r\n\r\nBasic Theory\r\n============\r\n\r\nTypes, Kinds and Type Constructors\r\n----------------------------------\r\n\r\nA *variable* has a *type*. For example, `x: Int` means the variable `x` has the type `Int`.\r\n\r\nA *proper type*, also known as an *inhabitated* type, is a type that can have values. The type Int is a proper type because it has values like 0 and 1. `List[Int]` is also an inhabited, or proper type, that is inhabited by values like `1 :: 2 :: Nil`, instances of a list.\r\n\r\nA *type constructor* is something that takes a type and produces a type. Examples are anything with type parameters like List or Option. Type constructors are not inhabited, it is not possible to have values of List or Option, only List\\[X\\] or Option\\[Y\\].\r\n\r\nIn type theory it is useful to denote different *kinds* of types so that we can talk more generally about types, type constructors, etc.\r\n\r\n### Extra Theory\r\n\r\nTypes are denoted with an asterisk: *Int* is of type \\*\r\n\r\nA type constructor taking a single type is denoted like this: `*\r\n-> *`, meaning that given a type, denoted by the first \\*, it will produce a new proper type, \\*. For example, A List given an Int will produce List\\[Int\\].\r\n\r\nSomething like Either\\[A, B\\], which takes two type parameters, is denoted like this: `*-> * -> *` because it takes two proper types and produces a type. `Either[Int, String]` is a proper type contructed with Either and two proper types, Int and String.\r\n\r\n*Kinds* are a way of describing similar types at an abstract level. `*`, `* ->\r\n*`, `* -> * -> *`, are *kinds*. Kinds are useful when working more abstractly with types, both proper and improper (inhabited or uninhabited).\r\n\r\nFurther reading [Wikipedia](https://en.wikipedia.org/wiki/Kind_(type_theory)) [Types of a Higher Kind](http://blogs.atlassian.com/2013/09/scala-types-of-a-higher-kind/) [Stack Exchange](http://programmers.stackexchange.com/a/255928/18311)\r\n\r\nTypeclasses\r\n-----------\r\n\r\nTypeclasses are an extremely common pattern used extensively in libraries like the [Typelevel](http://typelevel.org/) libraries. Martin Odersky et al describe typeclasses as follows:\r\n\r\n> Type classes are useful to solve several fundamental challenges in software engineering and programming languages. In particular type classes support retroactive extension: the ability to extend existing software modules with new functionality without needing to touch or re-compile the original source.\r\n\r\nRead more here: [Type Classes as Objects and Implicits](http://ropas.snu.ac.kr/~bruno/papers/TypeClasses.pdf)\r\n\r\nIn Scala, the typeclass pattern consists of several parts:\r\n\r\n-   a trait with one or more type parameters that defines some behaviour\r\n-   an optional companion object of the trait with *implicit* instances of the trait for common types like Strings or Options, and other types present in the standard library.\r\n\r\nFor example, a trait with a show method to transform a T into a String\r\n\r\n``` scala\r\n  trait Show[T] {\r\n    def show(t: T): String\r\n  }\r\n\r\n  // A companion object with some useful default instance of the typeclass\r\n  object Show {\r\n\r\n    implicit object StringShow extends Show[String] {\r\n      def show(s: String): String = s.toString\r\n    }\r\n\r\n    implicit object IntShow extends Show[Int] {\r\n      def show(t: Int) = t.toString\r\n    }\r\n\r\n    // This show requires a Show[T] so its a method\r\n    implicit def listShow[T](implicit tShow: Show[T]):  Show[List[T]]  = new Show[List[T]] {\r\n\r\n      def show(l: List[T]): String = {\r\n        val list = l.map(v ⇒ tShow.show(v)).mkString(\",\")\r\n        s\"List($list)\"\r\n      }\r\n\r\n    }\r\n   }\r\n\r\n  // Example of use\r\n  def foo[T](v: T)(implicit show: Show[T]) = show.show(v)\r\n\r\n  println(foo(\"hi\"))\r\n\r\n  println(foo(123))\r\n\r\n  println(foo(List(1,2,3,4,5)))\r\n```\r\n\r\nAs an exercise, implement Show\\[Option\\[T\\]\\] and Show\\[Either\\[A, B\\]\\]\r\n\r\nCommon types and what they represent\r\n====================================\r\n\r\nIt is not uncommon to read blogs or other articles in which the follow statements are made:\r\n\r\n-   Lists represent indeterminism\r\n-   Either is a disjoint union\r\n-   etc.\r\n\r\nWhat do they mean?\r\n\r\nOption (or Maybe)\r\n-----------------\r\n\r\nOption represents an optional value, or sometimes, success and failure.\r\n\r\nIt has two constructors: None and Some\\[T\\], where Some\\[T\\] contains a value of type T.\r\n\r\nOption is of kind `* -> *`\r\n\r\nList\r\n----\r\n\r\nLists represent lists of things, but they are often referred to as representing *indeterminism*. A function returning a list can return any number of values including nothing (the empty list), hence the list is being used to represent an indeterministic result.\r\n\r\nLists are *recursive* data structures because they are typically defined in terms of themselves: a list is either the empty list, Nil, or a single element followed by a list.\r\n\r\nList is of kind `* -> *`\r\n\r\nEither\r\n------\r\n\r\nEither is of kind `* -> * -> *`\r\n\r\nValidation\r\n----------\r\n\r\nIdentity\r\n--------\r\n\r\nIntuitively it simply wraps a value, it does not embody anything meaningful but is useful in some contexts beyond the scope of this document.\r\n\r\nIdentity is of kind `* -> *`\r\n\r\nFurther Reading\r\n---------------\r\n\r\n[Typeclassopedia](http://www.cs.tufts.edu/comp/150FP/archive/brent-yorgey/tc.pdf) [Modeling Uncertain Data using Monads and an Application to the Sequence Alignment Problem](https://pp.ipd.kit.edu/uploads/publikationen/kuhnle13bachelorarbeit.pdf) [Functors, Applicatives, And Monads In Pictures](http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html)\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}